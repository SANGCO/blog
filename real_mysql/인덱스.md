## 랜덤 I/O와 순차 I/O
랜덤 I/O라는 표현은 디스크 드라이브의 플래터(원판)를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미하는데,
사실 순차 I/O 또한 이 작업은 같다. 그렇다면 어떤 차이가 있을까?

3개의 페이지(16 * 3KB)를 디스크에 기록하기 위해서 순차 I/O는 1번 시스템 콜을 요청하지만, 랜덤 I/O는 3번 시스템 콜을 요청한다.
즉, 디스크에 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 1번 움직였고 랜덤 I/O는 디스크 헤드를 3번 움직인 것이다. 결국 순차 I/O가 랜덤 I/O보다
거의 3배 정도 빠르다고 볼 수 있다.

일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다. 여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만
읽도록 쿼리를 개선하는 것을 의미한다.

인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며, 풀 테이블 스캔은 순차 I/O를 사용한다. 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는
인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다. 이는 순차 I/O가 랜덤 I/O보다 훨씬 빨리 많은 레코드를 읽어올 수 있기 때문인데, 이런 형태는
OLTP(Online Transaction Processing) 성격의 웹 서비스보다는 데이터 웨어하우스나 통계 작업에서 자주 사용된다.

## 인덱스란?
DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태로 유지한다. 데이터 파일은 ArrayList와 같이 저장된 순서대로
별도의 정렬 없이 그대로 저장해 둔다.

결론적으로 DBMS에서 인덱스는 데이터의 저장(insert, update, delete) 성능을 희생하고 그 대신 데이터의 읽기(select) 속도를 높이는 기능이다.
테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지의 여부에 따라
결정돼야 한다.

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다. 테이블의 레코드가 100만 건이
저장돼 있는데, 그중에서 50만 건을 읽어야 하는 쿼리가 있다고 가정해 보자. 이 작업은 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적일지,
인덱스를 통해 필요한 50만 건만 읽어 오는 것이 효율적일지 판단해야 한다.

인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있는데, **일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서
직접 레코드 1건을 읽는 것보다 4~5배 정도 더 비용이 많이 드는 작업인 것으로 예측한다.** 즉, 인덱스를 통해 읽어야 할 레코드의 건수(물론 옵티마이저가 판단한
예상 건수)가 전체 테이블 레코드의 20 ~ 25%를 넘어서면 인덱스를 이용하지 말고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적이다.

## 다중 칼럼(Multi-column) 인덱스
실제 서비스용 DB에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용된다. 2개 이상의 칼럼이 연결됐다고 해서 "Concatenated Index"라고도 한다.

중요한 것은 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬 돼 있다는 점이다. 만약 칼럼이 4개인 인덱스를 생성한다면 세 번째 칼럼은 두 번째 칼럼에
의존해서 정렬되고 네 번째 칼럼은 다시 세 번째 칼럼에 의존해서 정렬된다. 다중 칼럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하며 또한
아주 신중히 결정해야 하는 이유가 바로 여기에 있다.

가끔 인덱스를 구성하는 칼럼 가운데 오름차순(ASC)과 내림차순(DESC)을 혼합해서 만들어야 할 때가 있는데 MySQL에서는 칼럼의 값을 역으로 변환해서
구현하는 것이 유일한 방법이다.
```
CREATE TABLE ranking(
  team_name VARCHAR(20),
  user_name VARCHAR(20),
  user_score INT,
  ...
  INDEX ix_teamname_userscore(team_name, user_score)
);
```
ranking 테이블에서 team_name 칼럼은 오름차순(ASC)으로 정렬하고 user_score는 높은 점수 순서(내림차순)대로 정렬해서 사용자를 조회하려면
어떻게 해야 할까?

```
SELECT team_name, user_name
FROM ranking
ORDER BY team_name ASC, user_score DESC;
```
위와 같이 쿼리를 사용하면 원하는 결과를 조회할 수 있다. 하지만 이 쿼리는 실행의 최종 단계에서 레코드를 정렬하는 과정이 필요하므로 절대로 빠르게 처리할 수 없다.
그래서 이럴 때는 user_score의 값을 역으로 변환해서 저장하는 것이 현재로서는 유일한 방법이다. 즉 user_score 값을 그대로 음수로 만들어서 저장하는 것이다.
그러면 ORDER BY의 정렬 조건을 모두 오름차순(ASC)으로 사용할 수 있게 되므로 별도의 정렬 작업 없이 인덱스를 읽기만 해도 정렬되어 출력되는 것이다.

## B-Tree 인덱스의 가용성과 효율성
쿼리의 WHERE 조건이나 GROUP BY 또는 ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다.
그래야만 쿼리의 조건을 최적화하거나, 역으로 쿼리에 맞게 인덱스를 최적으로 생성할 수 있다.

**비교 조건의 종류와 효율성**<br>
다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 비교(=)인지 아니면 크다(>) 또는 작다(<)와 같은 범위 조건인지에 따라 각 인덱스
칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.
```
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no >= 10114;
```
이 쿼리를 위해 dept_emp 테이블에 각각 칼럼의 순서만 다른 2가지 case로 인덱스를 생성했다고 가정하자. 위의 쿼리가 처리되는 동안 각 인덱스에
어떤 차이가 있었는지 살펴보자.

case A: dep_no + emp_no<br>
case B: emp_no + dep_no<br>

![](/assets/realmysql_index1.jpeg)

case A는 `dept_no='d002' AND emp_no >= 10114`인 레코드를 찾고, 그 이후에는 dept_no가 'd002'가 아닐 때까지 인덱스를 그냥 죽 읽기만 하면 된다.
이 경우에는 읽은 레코드가 모두 사용자가 원하는 결과라서 상당히 효율적으로 인덱스를 이용한 것이다.

하지만 case B는 우선 `emp_no >= 10114 AND dept_no='d002'`인 레코드를 찾고, 그 이후 모든 레코드에 대해 dept_no='d002'인지 비교하는
과정을 거쳐야 한다. 이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 필터링이라고 한다.

**인덱스의 가용성**<br>
B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있다는 것이다. 여기서 왼쪽이라 함은 하나의 칼럼 내에서뿐만 아니라 다중 칼럼 인덱스의 칼럼에
대해서도 함께 적용된다.

case A: INDEX(first_name)<br>
case B: INDEX(dept_no, emp_no)<br>

![](/assets/realmysql_index2.jpeg)

위 그림에서는 정렬만 표현했지만, 사실은 이 정렬이 빠른 검색의 전제 조건이다. 즉 하나의 칼럼으로 검색해도 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔
방식의 검색이 불가능하다. 또한 다중 칼럼 인덱스에서도 왼쪽 칼럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다.

```
SELECT * FROM employees WHERE first_name LIKE '%mer';
```
이 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수는 없다. 그 이유는 first_name 칼럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서
일치하는 레코드를 찾아야 하는데, 조건절에 주어진 상수값("%mer")에는 왼쪽 부분이 고정되지 않았기 때문이다.

```
SELECT * FROM dept_emp WHERE emp_no >= 10144;
```
case B의 인덱스가 지정된 dept_emp 테이블에 대해 다음 쿼리가 어떻게 실행되는지 보자.
인덱스가 (dept_no, emp_no) 칼럼 순서대로 생성돼 있다면 인덱스의 선행 칼럼인 dept_no 값 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할
수 없다. case B의 인덱스는 다중 칼럼으로 인덱스가 만들어졌기 때문에 dept_no에 대해 먼저 정렬한 후, 다시 emp_no 칼럼값으로 정렬돼 있기 때문이다.

**가용성과 효율성 판단**<br>
기본적으로 B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없다. 여기서 사용할 수 없다는 것은 작업 범위 결정 조건으로 사용할 수 없다는 것을 의미하며,
경우에 따라서는 체크 조건으로 인덱스를 사용할 수는 있다.

1. NOT-EQUAL로 비교된 경우 ("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
2. LIKE '%??' (앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
3. 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
4. NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
5. 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
6. 문자열 데이터 타입의 콜레이션이 다른 경우(콜레이션은 문자열 칼럼의 값에 대한 비교나 정렬 순서를 위한 규칙을 의미한다)

다른 일반적인 DBMS에서는 NULL 값은 인덱스에 저장되지 않지만 MySQL에서는 NULL 값도 인덱스로 관리된다. 다음과 같은 WHERE 조건도 작업 범위 결정
조건으로 인덱스를 사용한다.
```
.. WHERE column IS NULL ..
```

다중 칼럼으로 만들어진 인덱스는 어떤 조건에서 사용될 수 있고, 어떤 경우에는 절대 사용될 수 없는지 살펴보자. 다음과 같은 인덱스가 있다고 가정해 보자.
```
INDEX ix_test ( column_1, column_2, column_3, ... column_n )
```
작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
- column_1 칼럼에 대한 조건이 없는 경우
- column_1 칼럼의 비교 조건이 의의 인덱스 사용 불가 조건 중 하나인 경우

작업 범위 결정 조건으로 인덱스를 사용하는 경우(i는 2보다 크고 n보다 작은 임의의 값을 의미)
- column_1 ~ column_(i-1) 칼럼까지 Equal 형태("=" 또는 "IN")로 비교
- column_i 칼럼에 대해 다음 연산자 중 하나로 비교
  - Equal("=" 또는 "IN")
  - 크다 작다 현태(">" 또는 "<")
  - LIKE로 좌측 일치 패턴(LIKE '승환%')


